
#ifndef HEXASPHERE_STEREOGRAPHIC_SHADER_H
#define HEXASPHERE_STEREOGRAPHIC_SHADER_H

#include "common.shaderh"

/**
 * This function is used for taking a vertex position which is on (or very near) the unit sphere and performing a
 * stereographic projection using only the camera parameters which can be determined from the uniforms provided.
 * Points on the unit sphere will be taken to a point on the z = 1 plane (before being passed through the perspective
 * matrix/transformation). Points slighly outside of the unit sphere will be taken to a point where z < 1 in such a way
 * that once passed through the perspective transformation they will appear to have a parallax effect compared to the
 * unit sphere.
 *
 * @author sergeys
 */
vec4 computeStereographicPosition(vec4 modelPosition) {
    // A constant to determine how much parallax should be added
    float factor3d = 1.0;

    // Convert from homogenous coordinates
    modelPosition /= modelPosition.w;

    // Only take the rotation component of the view matrix
    // This will rotate the model to face the correct direction
    vec3 sphereCoord = mul(mat3FromMat4(u_view), modelPosition.xyz);
    // Compute the distance (which will be used to normalize and add a parallax effect)
    float distance = length(sphereCoord);
    // Perform the normalization
    vec3 normalized = sphereCoord / distance;
    // It needs to be negated because I want to see the close side projected in and the far side projected out
    normalized = -normalized;

    // Perform the stereographic projection
    vec2 projection = vec2(normalized.x / (1 - normalized.z), normalized.y / (1 - normalized.z));

    // Compute a scaling factor from the camera's distance to the sphere
    // This scaling factor was chosen so that the output image is similar to a normal perspective projection
    float scaling = (length(mtxGetCol4(u_view).xyz) - 1.0) * 0.5;

    // Scale the projection
    projection /= scaling;

    // Now that we have performed the stereographic projection we need to apply parallax and trick
    // the GPU into not rendering any polygons which contain the point at infinity

    // For the first part simply pass the projected surface through the projection matrix
    // This has the added benefit of applying aspect ratio and trying to keep all camera settings as similar as possible
    // Thus all steps prior to the projection matrix multiplication can be thought of as operating on geometry
    // rather than operating on the camera

    // So we convert out 2d projected geometry into 3d by making it stick out towards the camera proporitonal to how
    // far off of the surface of the sphere it sits
    vec3 parallax = vec3(projection, 1.0 - (distance - 1.0) * factor3d);
    // Then we pass this through the projection matrix to end up with an image (which will include a parallax effect
    // generated by effectively wrapping the radial direction in the original sphere into the -z direction)
    vec4 result = mul(u_proj, vec4(parallax, 1.0) );
    // Convert from homogenous coordinates because I want to manually change the depth (z-value) of this vertex
    result /= result.w;

    // This is the second part. We want to hide any polygons which contain the point at infinity
    // I want to hide these because they are polygons from the original surface which contain the directly opposite
    // side of the sphere
    // Thus the stereographic projection ends up failing for them as the actual polygon ends up containing almost all of
    // the other polygons
    // So I trick the GPU into hiding this polygon by placing it behind all of the other polygons (thus the depth
    // test will get rid of it)
    // So I set the depth of this polygon such that it is based upon the sphere from before the stereographic projection
    // I take the z position of the vertex from that point and rescale it so that it falls in the range [0.5, 1.0]
    // While this range is arbitrary I chose it because I don't know in this shader whether it is OpenGL or DirectX
    // OpenGL expects a z-range of [-1, 1] and DX expects [0, 1]
    // Thus I chose to put it in the range [0.5, 1.0] so that I would still have 0.5 units to play with here in order to
    // put anything sticking up from the sphere above the sphere (so that you can see the parallax effect)
    result.z = normalized.z / 4.0 + 0.75 - (distance - 1.0) * factor3d;

    return result;
}

#endif // HEXASPHERE_STEREOGRAPHIC_SHADER_H
